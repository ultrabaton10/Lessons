# Формулировка задания:
# Необходимо разработать такой алгоритм,
# который будет искать одну последовательность элементов в другой последовательности эелементов
# Пример:
# Пусть имеется массив - 'lililos lililas'
# Необходимо найти совпадение последовательности 'lilila' в исходном массиве
# Для этого можно организовать следующий алгоритм:
# Можно каждый раз накладывать строчку 'lilila' на элементы массива,
# при этом, если не найдётся результат,
# то мы начнём накладывать строчку 'lilila' на элементы этого же массива,
# но начиная уже со второго элемента, а не первого
# Тогда, алгоритмическая сложность будет составлять:
# число элементов исходного массива помноженное на число элементов строки (m x n)
# Это долгий алгоритм
# Фухх, вот я и написал этот алгоритм, причём, я написал простой КМП, а не сложный,
# а время потратил ну часа 2 - это 100%


# str1 = 'i have got my number: 8-800-555-35-35, say me what you got a number?'
# str2 = 'my number: 8-800-555-35-33'


def search_simple(str1, str2):  # самая сложная функция, которую я когда-либо писал(((
    for i in range(len(str1)):
        c = 0
        for j in range(len(str2)):
            if str1[j + i] == str2[j]:
                c += 1
            else:
                c = 0
                break
        if c == len(str2) and c != 0:
            return True
    return False


# print(search_simple(str1, str2))


#  Ага, я понял, что этот КМП настолько сложный, что его никак не понять и не написать,
#  если не разбить его на подзадачи.
#  Поэтому, сначала организуем алгоритм,
#  который будет формировать список пи(я не тролль, но пускай так и будет называться),
#  в котором будут значения длин максимальных суффиксов.
#  Что такое максимальные суффиксы ?
#  Ну типа это максимальная длина симметричной части последовательности.
#  Пример:
#  Пусть есть последовательность ЛИЛИ.
#  Тогда мы начинаем рассуждать так:
#  Так как нам нужно найти максимальную длину последовательности,
#  которая будет симметрична при наложении на другую последовательность,
#  то будем отсчитывать от нулевого элемента.
#  В начале у нас в списке пи стоит 0, потому что первый элемент, несмотря на то, что равен самому себе,
#  он не является последующим элементом, то есть если мы по такой логике будем сравнивать,
#  то каждый элемент будет равен самому себе, что не логично вообще.
#  Тогда мы будем сравнивать каждый раз с последующим элементом.
#  Тогда получается что мы сравнили 'Л' и 'И': они не равны, значит сравниваем 'Л' и следующий элемент.
#  Сравниваем 'Л' и 'Л', они равны, значит теперь сравниваем следующие два элемента,
#  идущие после первой 'Л' и второй 'Л'. Это у нас 'И' и 'И'. Всё максимальная длина суффикса 2.
#  На этом примеры мы не полностью разобрали алгоритм, так как у нас был простой вариант,
#  потому что последующие элементы после совпавших двух предыдущих, тоже совпали.
#  А вот теперь рассмотрим другой пример, в котором последующие элементы после двух совпавших будут отличаться.
#  Пусть у нас имеется последовательность I O I I O I O, я взял другие буквы,
#  потому что их проще отделить друг от друга.
#  Доработка алгоритма:
#  После того момента, когда мы доходим до двух равных значений элементов и сразу же
#  после этого мы сравниваем последующие элементы которые оказываются не равными,
#  то мы берём и откатываем назад тот элемент, который является первым из двух.
#  Итак, начнём:
#  ======================================= | 0
#  Begin I and O, they not equal, continue | 0
#  Next is I and I, ok, they equal, continue | 1
#  Next is O and I, ok, they not equal, continue | 0
#  Next is I and I, ok, they equal, continue | 1
#  Next is O and O, ok, they equal, continue | 2
#  Next is I and I, ok, they equal, continue | 3
#  Next is I and I, ok, they equal, continue | 4
#  Next is I and O, ok, they not equal, continue | 0
#  End.

#  Попробуем реализовать этот алгоритм


def searh_equal_postfix(s : str):
    pi = [0] * len(s)
    i = 1
    j = 0
    while i < len(s):
        if s[i] != s[j]:
            if j == 0:
                pi[i] = 0
                i += 1
            else:
                j = pi[j - 1]
        else:
            pi[i] = j + 1
            i += 1
            j += 1
    return pi


#  s = 'iooiiooiiiooo'
#  print(searh_equal_postfix(s))
#  Так, ну ясен пень, что я афигел с этого всего.
#  Причём я разобрал на бумажку вторую часть алгоритма КМП(звучит уже адски) на бумажке, но сейчас я всё перепишу
#  Итак, у нас уже есть массив пи, мы его ранее сформировали. У нас есть последовательность(str1),
#  с которой мы будем сравнивать искомую последовательность(str2).
#  Щас всё проговорим, потом напишем.
#  Пусть у нас имеется str1 = I O I O I O I A S T - I O I O I U S T
#  И str2 = I O I O I A
#  Вначале мы, конечно же будем сравнивать первые элементы обоих последовательностей.
#  Сравниваем I и I, они равны; прибавляем 1 к i и j;
#  Далее сравниваем O и O; они равны; прибавляем 1 к i и j;
#  Далее сравниваем I и I; они равны; прибавляем 1 к i и j;
#  Далее сравниваем O и O; они равны; прибавляем 1 к i и j;
#  Далее сравниваем I и I; они равны; прибавляем 1 к i и j;
#  Далее сравниваем O и O; они равны; прибавляем 1 к i и j;
#  Далее сравниваем I и I; они равны; прибавляем 1 к i и j;
#  Далее сравниваем A и O; они не равны; значит проверяем: если j > 0,
#  то j = элемент массива пи, который по индексу равен j - 1; иначе i++
#  И так далее...
#  Причём каждый раз мы проверяем, когда нашли равные элементы:
#  если j == длине массива str2, то мы нашли совпадение, на этом цикл завершается.
#  И также весь этот алгоритм находится в цикле с условием его выполнения пока i < длины массива str2 - 1
#  Этого достаточно, чтобы написать код
#  Let`s get it!


def search_KMP(pi : list[int],
               str1 : str,
               str2 : str):
    i = 0
    j = 0
    while i != len(str1):
        if str1[i] == str2[j]:
            i += 1
            j += 1
            if j == len(str2):
                return True
        elif j > 0:
            j = pi[j - 1]
        else:
            i += 1
    return False

str1 = 'IOIOIOIAST-IOIOIUST'
str2 = 'IOIOIOIA'
print(search_KMP(searh_equal_postfix(str2), str1, str2))
